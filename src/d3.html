<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://d3js.org/d3.v4.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
</head>
<body>
    

<!-- Apply specific style to the elements that have the class `inGreen` -->
<style>
  .inGreen { color: green; }
  .sizey {font-size: 20px;}
</style>

<!-- Add a title. Note that the class 'inGreen' is given to this title -->
<h1 class="inGreen">First html document</h1>
<!-- Load d3.js and plugin for color scale -->


<!-- Create a div where the graph will take place -->
<div id="my_dataviz"></div>

<!-- Add a bit of text -->
<p>This is my first sentence</p>

<!-- Add a link -->
<p>This is <a href="https://www.d3-graph-gallery.com">a link to the d3 graph gallery</a></p>
<svg>
    <!-- <line x1="0" y1="0" x2="10" y2="10" stroke="black"></line>
<rect x="0" y="0" width="10" height="10"></rect>
<circle cx="5" cy="5" r="5"></circle>
<ellipse cx="10" cy="5" rx="10" ry="5"></ellipse>
<polygon points="0,0 10,5 20,0 20,20 10,15 0,20"></polygon> -->
<polyline points="0,0 10,5 20,0 20,20 10,15 0,20" stroke="black"></polyline>
<!-- <path d="M65,10 a50,25 0 1,0 50,25"></path> -->
    <circle style="fill: #69b3a2" stroke="black" cx=50 cy=50 r=40></circle>
  </svg>
  <script>

    // set the dimensions and margins of the graph
    var margin = {top: 10, right: 30, bottom: 30, left: 40},
        width = 460 - margin.left - margin.right,
        height = 400 - margin.top - margin.bottom;
    
    // append the svg object to the body of the page
    var svg = d3.select("#my_dataviz")
      .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
      .append("g")
        .attr("transform",
              "translate(" + margin.left + "," + margin.top + ")");
    
    // Read the data and compute summary statistics for each specie
    d3.csv("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/iris.csv", function(data) {
    
      // Build and Show the Y scale
      var y = d3.scaleLinear()
        .domain([ 3.5,8 ])          // Note that here the Y scale is set manually
        .range([height, 0])
      svg.append("g").call( d3.axisLeft(y) )
    
      // Build and Show the X scale. It is a band scale like for a boxplot: each group has an dedicated RANGE on the axis. This range has a length of x.bandwidth
      var x = d3.scaleBand()
        .range([ 0, width ])
        .domain(["setosa", "versicolor", "virginica"])
        .padding(0.05)     // This is important: it is the space between 2 groups. 0 means no padding. 1 is the maximum.
      svg.append("g")
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(x))
    
      // Features of the histogram
      var histogram = d3.histogram()
            .domain(y.domain())
            .thresholds(y.ticks(20))    // Important: how many bins approx are going to be made? It is the 'resolution' of the violin plot
            .value(d => d)
    
      // Compute the binning for each group of the dataset
      var sumstat = d3.nest()  // nest function allows to group the calculation per level of a factor
        .key(function(d) { return d.Species;})
        .rollup(function(d) {   // For each key..
          input = d.map(function(g) { return g.Sepal_Length;})    // Keep the variable called Sepal_Length
          bins = histogram(input)   // And compute the binning on it.
          return(bins)
        })
        .entries(data)
    
      // What is the biggest number of value in a bin? We need it cause this value will have a width of 100% of the bandwidth.
      var maxNum = 100
      for ( i in sumstat ){
        allBins = sumstat[i].value
        lengths = allBins.map(function(a){return a.length;})
        longuest = d3.max(lengths)
        if (longuest > maxNum) { maxNum = longuest }
      }
    
      // The maximum width of a violin must be x.bandwidth = the width dedicated to a group
      var xNum = d3.scaleLinear()
        .range([0, x.bandwidth()])
        .domain([-maxNum,maxNum])
    
      // Color scale for dots
      var myColor = d3.scaleSequential()
        .interpolator(d3.interpolateInferno)
        .domain([3,9])
    
      // Add the shape to this svg!
      svg
        .selectAll("myViolin")
        .data(sumstat)
        .enter()        // So now we are working group per group
        .append("g")
          .attr("transform", function(d){ return("translate(" + x(d.key) +" ,0)") } ) // Translation on the right to be at the group position
        .append("path")
            .datum(function(d){ return(d.value)})     // So now we are working bin per bin
            .style("stroke", "none")
            .style("fill","grey")
            .attr("d", d3.area()
                .x0( xNum(0) )
                .x1(function(d){ return(xNum(d.length)) } )
                .y(function(d){ return(y(d.x0)) } )
                .curve(d3.curveCatmullRom)    // This makes the line smoother to give the violin appearance. Try d3.curveStep to see the difference
            )
    
      // Add individual points with jitter
      var jitterWidth = 40
      svg
        .selectAll("indPoints")
        .data(data)
        .enter()
        .append("circle")
          .attr("cx", function(d){return(x(d.Species) + x.bandwidth()/2 - Math.random()*jitterWidth )})
          .attr("cy", function(d){return(y(d.Sepal_Length))})
          .attr("r", 5)
          .style("fill", function(d){ return(myColor(d.Sepal_Length))})
          .attr("stroke", "white")
    
    })
    
    </script>

<script src="https://d3js.org/d3.v4.js"></script>

<!-- Create a div where the graph will take place -->
<div id="my_dataviz"></div>

<p>
  <label># bins</label>
  <input type="number" min="1" max="100" step="30" value="20" id="nBin">
</p>
<script>

    // set the dimensions and margins of the graph
    var margin = {top: 10, right: 30, bottom: 30, left: 40},
        width = 460 - margin.left - margin.right,
        height = 400 - margin.top - margin.bottom;
    
    // append the svg object to the body of the page
    var svg = d3.select("#my_dataviz")
      .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
      .append("g")
        .attr("transform",
              "translate(" + margin.left + "," + margin.top + ")");
    
    // get the data
    d3.csv("https://raw.githubusercontent.com/holtzy/data_to_viz/master/Example_dataset/1_OneNum.csv", function(data) {
    
      // X axis: scale and draw:
      var x = d3.scaleLinear()
          .domain([0, 1000])     // can use this instead of 1000 to have the max of data: d3.max(data, function(d) { return +d.price })
          .range([0, width]);
      svg.append("g")
          .attr("transform", "translate(0," + height + ")")
          .call(d3.axisBottom(x));
    
      // Y axis: initialization
      var y = d3.scaleLinear()
          .range([height, 0]);
      var yAxis = svg.append("g")
    
      // A function that builds the graph for a specific value of bin
      function update(nBin) {
    
        // set the parameters for the histogram
        var histogram = d3.histogram()
            .value(function(d) { return d.price; })   // I need to give the vector of value
            .domain(x.domain())  // then the domain of the graphic
            .thresholds(x.ticks(nBin)); // then the numbers of bins
    
        // And apply this function to data to get the bins
        var bins = histogram(data);
    
        // Y axis: update now that we know the domain
        y.domain([0, d3.max(bins, function(d) { return d.length; })]);   // d3.hist has to be called before the Y axis obviously
        yAxis
            .transition()
            .duration(1000)
            .call(d3.axisLeft(y));
    
        // Join the rect with the bins data
        var u = svg.selectAll("rect")
            .data(bins)
    
        // Manage the existing bars and eventually the new ones:
        u
            .enter()
            .append("rect") // Add a new rect for each new elements
            .merge(u) // get the already existing elements as well
            .transition() // and apply changes to all of them
            .duration(1000)
              .attr("x", 1)
              .attr("transform", function(d) { return "translate(" + x(d.x0) + "," + y(d.length) + ")"; })
              .attr("width", function(d) { return x(d.x1) - x(d.x0) -1 ; })
              .attr("height", function(d) { return height - y(d.length); })
              .style("fill", "#69b3a2")
    
    
        // If less bar in the new histogram, I delete the ones not in use anymore
        u
            .exit()
            .remove()
    
        }
    
    
      // Initialize with 20 bins
      update(20)
    
    
      // Listen to the button -> update if user change it
      d3.select("#nBin").on("input", function() {
        update(+this.value);
      });
    
    });
    </script>
    <script>
        d3
          .select(".target")  // select the elements that have the class 'target'
          .style("stroke-width", 8) // change their style: stroke width is not equal to 8 pixels
        </script>
        <script>
            var svg = d3.select("#dataviz_area")
            svg.append("circle")
              .attr("cx", 2).attr("cy", 2).attr("r", 40).style("fill", "blue");
            svg.append("circle")
              .attr("cx", 140).attr("cy", 70).attr("r", 40).style("fill", "red");
            svg.append("circle")
              .attr("cx", 300).attr("cy", 100).attr("r", 40).style("fill", "green");
            </script>

</body>
</html>